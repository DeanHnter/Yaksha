import raylib as rl

def remap(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64:
    # Map x to be from 'a to b' range to 'c to d' range
    if a == b:
        return 0.0
    return (x - a) / (b - a) * (d - c) + c

@nativemacro
def pi() -> f64:
    # Get approximate PI value
    ccode """PI"""

@nativemacro
def torad(degrees: f64) -> f64:
    ccode """nn__degrees * DEG2RAD"""

@nativemacro
def todeg(radians: f64) -> f64:
    ccode """nn__radians * RAD2DEG"""

@nativemacro
def sin_deg(x: f64) -> f64:
    ccode """sin(nn__x * DEG2RAD)"""

@nativemacro
def cos_deg(x: f64) -> f64:
    ccode """cos(nn__x * DEG2RAD)"""

@nativemacro
def tan_deg(x: f64) -> f64:
    ccode """tan(nn__x * DEG2RAD)"""

@native
def lerp_color(a: rl.Color, b: rl.Color, fraction: f64) -> rl.Color:
    ccode """float x = (float)nn__fraction;
    if (x > 1.0) {
        x = 1.0;
    }
    if (x < 0.0) {
        x = 0.0;
    }
    double r = (nn__b.r - nn__a.r) * x - (nn__a.r);
    double g = (nn__b.g - nn__a.g) * x - (nn__a.g);
    double b = (nn__b.b - nn__a.b) * x - (nn__a.b);
    double a = (nn__b.a - nn__a.a) * x - (nn__a.a);
    return (Color){(unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a}
    """

@native
def clear() -> None:
    # Clear background with RAYWHITE colour
    ccode """ClearBackground(RAYWHITE)"""