import libs.c


######## Byte level access

@native
def get_cstr(s: c.CStr, pos: int) -> int:
    ccode """return (int32_t)nn__s[nn__pos]"""

@native 
def set_cstr(s: c.CStr, pos: int, v: int) -> None:
    ccode """nn__s[nn__pos] = nn__v;"""

@native
def get(s: str, pos: int) -> int:
    ccode """int32_t x = (int32_t)nn__s[nn__pos];
    yk__sdsfree(nn__s);
    return x"""

######## Utils

@nativemacro
def valid(s: str) -> bool:
    ccode """(NULL != nn__s)"""

@nativemacro
def valid_cstr(s: c.CStr) -> bool:
    ccode """(NULL != nn__s)"""

@native
def isempty(s: str) -> bool:
    ccode """bool x = yk__sdslen(nn__s) == 0;
    yk__sdsfree(nn__s);
    return x"""

@native
def isempty_cstr(s: c.CStr) -> bool:
    ccode """bool x = strlen(nn__s) == 0;
    yk__sdsfree(nn__s);
    return x"""

@native
def ord_cstr(s: c.CStr) -> int:
    ccode """return (int32_t)nn__s[0]"""

def ord(s: str) -> int:
    return get(s, 0)

@native
def startswith(a: str, b: str) -> bool:
    ccode """bool x = (strstr(nn__a, nn__b) != NULL);
    yk__sdsfree(nn__a);
    yk__sdsfree(nn__b);
    return x"""

@native
def split(value: str, sep: str) -> Array[str]:
    ccode """int count;
    yk__sds* result = yk__sdssplitlen(nn__value, yk__sdslen(nn__value),
            nn__sep, yk__sdslen(nn__sep), &count);
    yk__sdsfree(nn__value);
    yk__sdsfree(nn__sep);
    if (NULL == result) {
        return NULL;
    }
    yk__sds* newarr = NULL;
    for (int i = 0; i < count; i++) {
        yk__arrput(newarr, result[i]);
    }
    free(result); // free array itself.
    return newarr"""

############ Conversions and deletions

@native
def from_cstr(a: c.CStr) -> str:
    ccode """return yk__sdsnewlen(nn__a, strlen(nn__a))"""

@native
def from_cstrlen(a: c.CStr, length: int) -> str:
    ccode """return yk__sdsnewlen(nn__a, nn__length)"""

@native
def from_cstrlen_after(a: c.CStr, length: int, after: int) -> str:
    ccode """return yk__sdsnewlen(nn__a + nn__after, nn__length)"""

# Yaksha copies managed strings that you pass in so must free this.
@native
def to_cstr(a: str) -> c.CStr:
    ccode """return nn__a"""

# Delete a native c-string created from other other functions (calls free)
@native
def del_cstr(a: c.CStr) -> None:
    ccode """free(nn__a)"""

# Delete a normal string that was casted as a c-str with to_cstr (calls runtime sdsfree)
@native
def del_str(a: c.CStr) -> None:
    ccode """if (NULL == nn__a) return;
    yk__sdsfree(nn__a)"""

# to delete a str just use del

############ UTF8 iteration


@nativedefine("struct utf8proc_iter_state*")
class Utf8IterateState:
    step_size: int
    codepoint: int

@native
def new_iter(s: str) -> Utf8IterateState:
    ccode """struct utf8proc_iter_state* x = calloc(1, sizeof(struct utf8proc_iter_state));
    if (x == NULL) return x;
    x->str_original = (utf8proc_uint8_t *) nn__s;
    x->str_position = (utf8proc_uint8_t *) nn__s;
    x->length = yk__sdslen(nn__s);
    x->step_size = 0;
    x->codepoint = -1;
    return x"""

@native
def del_iter(s: Utf8IterateState) -> None:
    ccode """yk__sdsfree((yk__sds)nn__s->str_original);
    free(nn__s)"""

@native
def iterate(s: Utf8IterateState) -> bool:
    ccode """if (nn__s->length <= 0) { return false; }
    utf8proc_int32_t val;
    utf8proc_ssize_t read_bytes = utf8proc_iterate(nn__s->str_position, nn__s->length, &val);
    if (read_bytes <= 0) {
        return false;
    } 
    nn__s->str_position += read_bytes;
    nn__s->length -= read_bytes;
    nn__s->step_size = read_bytes;
    nn__s->codepoint = val;
    return true"""
