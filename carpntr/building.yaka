import libs.console
import libs.io
import libs.os.path
import libs.os
import libs.strings
import libs.strings.buffer as sbuf
import libs.strings.array as sarr
import configuration as carp

def prepare_code(c: carp.Config, code: str) -> str:
    buf: sbuf.StringBuffer = sbuf.new()
    defer sbuf.del_buf(buf)
    # --
    length: int = 0
    x: int = 0
    # write #defines
    length = len(c.c_code.defines)
    x = 0
    while x < length:
        sbuf.append(buf, "#define " + c.c_code.defines[x] + "\n")
        x = x + 1
    # write #include <>
    length = len(c.c_code.system_includes)
    x = 0
    while x < length:
        sbuf.append(buf, "#include <" + c.c_code.system_includes[x] + ">\n")
        x = x + 1
    # write #include ""
    length = len(c.c_code.includes)
    x = 0
    while x < length:
        sbuf.append(buf, "#include \"" + c.c_code.includes[x] + "\"\n")
        x = x + 1
    # code itself
    sbuf.append(buf, code)
    sbuf.append(buf, "\n")
    # to string
    result: str = sbuf.to_str(buf)
    return result

def create_args(c: carp.Config, code_path: str, build_path: str, target: str) -> Array[str]:
    native: bool = len(target) == 0
    args: Array[str] = sarr.new(8, c.zig_compiler_path, "cc", "-std=c99", "-Oz", "-pedantic", "-Wall", "-Wno-newline-eof", "-fPIC")
    if (native and (not os.is_macos())) or (not native and not strings.contains(target, "macos")):
        arrput(args, "-flto=full")
    # --
    length: int = 0
    x: int = 0
    # include paths
    length = len(c.c_code.include_paths)
    x = 0
    while x < length:
        include: str = "-I" + c.c_code.include_paths[x]
        arrput(args, include)
        x = x + 1
    # compiler defines
    length = len(c.c_code.compiler_defines)
    x = 0
    while x < length:
        cdefine: str = "-D" + c.c_code.compiler_defines[x]
        arrput(args, cdefine)
        x = x + 1
    # c codes
    length = len(c.c_code.c_code)
    x = 0
    while x < length:
        cc: str = c.c_code.c_code[x]
        arrput(args, cc)
        x = x + 1
    # program code
    arrput(args, code_path)
    # yk__main.c
    the_yk_main: str = path.join(c.runtime_path, "yk__main.c")
    arrput(args, the_yk_main)
    # Target architecture
    if not native:
        arrput(args, "-target")
        arrput(args, target)
    # -o bin.exe
    arrput(args, "-o")
    binary: str = c.project.name
    if not native:
        binary = binary + "-" + target
    if (native and os.is_windows()) or strings.contains(target, "windows"):
        binary = binary + ".exe"
    binary = path.join(build_path, binary)
    arrput(args, binary)
    # ----
    return args

def build_target(c: carp.Config, code_path: str, build_path: str, target: str) -> int:
    a: Array[str] = create_args(c, code_path, build_path, target)
    defer sarr.del_str_array(a)
    result: os.ProcessResult = os.run(a)
    defer os.del_process_result(result)
    if len(target) == 0:
        console.yellow("native ")
    else:
        console.yellow(target)
    console.cyan(":= ")
    if result.ok:
        console.green("done.\n")
        return 0
    else:
        console.red("failed.\n")
        console.cyan("-------\n")
        console.red(result.output)
        return 1

def build(c: carp.Config, code: str) -> int:
    print("\nbuilding ")
    print(len(c.compilation.targets) + 1)
    println(" target(s) ...")
    build_path: str = path.join(os.cwd(), "build")
    code_path: str = path.join(build_path, "program_code.c")
    if not io.writefile(code_path, prepare_code(c, code)):
        console.red("Failed to write file:")
        println(code_path)
        return -1

    failed_count: int = 0
    # Build current system native binary
    failed_count = failed_count + build_target(c, code_path, build_path, "")

    # Building other targets
    cnt: int = 0
    while cnt < len(c.compilation.targets):
        target: str = c.compilation.targets[cnt]
        failed_count = failed_count + build_target(c, code_path, build_path, target)
        cnt = cnt + 1

    print("\n")
    if failed_count > 0:
        return -1
    else:
        return 0