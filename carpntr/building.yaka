import libs.console
import libs.io
import libs.os.path
import libs.os
import libs.strings
import libs.strings.buffer as sbuf
import libs.strings.array as sarr
import raylib_support as rs
import configuration as carp

def prepare_code(c: carp.Config, code: str) -> str:
    # Prepare code for compilation based on configuration
    # Injects includes, defines, etc
    # Then return final code
    buf: sbuf.StringBuffer = sbuf.new()
    defer sbuf.del_buf(buf)
    # --
    length: int = 0
    x: int = 0
    # write #runtime_defines
    length = len(c.c_code.runtime_feature_defines)
    x = 0
    while x < length:
        sbuf.append(buf, "#define " + c.c_code.runtime_feature_defines[x] + "\n")
        x = x + 1
    # write #defines
    length = len(c.c_code.defines)
    x = 0
    while x < length:
        sbuf.append(buf, "#define " + c.c_code.defines[x] + "\n")
        x = x + 1
    # write #include <>
    length = len(c.c_code.system_includes)
    x = 0
    while x < length:
        sbuf.append(buf, "#include <" + c.c_code.system_includes[x] + ">\n")
        x = x + 1
    # Add raylib.h & friends
    if c.compilation.raylib:
        sbuf.append(buf, "#include \"raylib.h\"\n")
        sbuf.append(buf, "#include \"raygui.h\"\n")
        sbuf.append(buf, "#include \"raymath.h\"\n")
        sbuf.append(buf, "#include \"rlgl.h\"\n")
        sbuf.append(buf, "#include \"rayextras.h\"\n")
    # write runtime feature #include ""
    length = len(c.c_code.runtime_feature_includes)
    x = 0
    while x < length:
        sbuf.append(buf, "#include \"" + c.c_code.runtime_feature_includes[x] + "\"\n")
        x = x + 1
    # write #include ""
    length = len(c.c_code.includes)
    x = 0
    while x < length:
        sbuf.append(buf, "#include \"" + c.c_code.includes[x] + "\"\n")
        x = x + 1
    # code itself
    sbuf.append(buf, code)
    sbuf.append(buf, "\n")
    # to string
    result: str = sbuf.to_str(buf)
    return result

def is_target_macos(target_to_check: str) -> bool:
    # Check if given target is macos, if target == native, check if we are running macos
    native: bool = len(target_to_check) == 0
    if native:
        return os.is_macos()
    return strings.contains(target_to_check, "macos")

def is_target_windows(target_to_check: str) -> bool:
    # Check if given target is windows, if target == native, check if we are running windows
    native: bool = len(target_to_check) == 0
    if native:
        return os.is_windows()
    return strings.contains(target_to_check, "windows")

def produce_core_object(args: Array[str], c_file: str, build_path: str, target: str, always_build: bool) -> str:
    # Copy the arguments so we can add -c and -o of our own
    my_args: Array[str] = sarr.dup(args)
    defer sarr.del_str_array(my_args)
    suffix: str = "-"
    # native
    native: bool = len(target) == 0
    if native:
        suffix += "native"
    else:
        suffix += target
    object_file: str = path.remove_extension(path.basename(c_file))
    object_file += suffix
    object_file += ".o"
    object_file_path: str = path.join(build_path, object_file)

    console.cyan("runtime::")
    console.yellow(object_file)
    console.cyan(" := ")
    # Skip building if allowed
    if not always_build and path.readable(object_file_path):
        console.green("prebuilt.\n")
        return object_file_path

    arrput(my_args, "-c")
    arrput(my_args, c_file)
    arrput(my_args, "-o")
    arrput(my_args, object_file_path)

    pr: os.ProcessResult = os.run(my_args)
    defer os.del_process_result(pr)

    if pr.ok:
        console.green("done.\n")
    else:
        console.red("failed.\n")
        console.cyan("--c compiler output---\n")
        console.red("command := ")
        console.cyan(sarr.join(my_args, " ") + "\n")
        console.red(pr.output)
        console.cyan("--end c compiler output---\n")

    return object_file_path

def create_args(c: carp.Config, code_path: str, build_path: str, target: str, raylib_args: Array[str]) -> Array[str]:
    # Create arguments for compilation on to a string array
    # This string array need to be deleted
    native: bool = len(target) == 0
    args: Array[str]
    objects: Array[str]
    if c.compilation.web:
        args = array("str", c.emcc_compiler_path, "-std=c99", "-Oz", "-Wno-newline-eof", "-Wno-parentheses-equality")
    else:
        args = array("str", c.zig_compiler_path, "cc", "-std=c99", "-Oz", "-pedantic", "-Wall", "-Wno-newline-eof", "-fPIC", "-Wno-parentheses-equality")
    args = sarr.extend(args, raylib_args)
    # If not macos do link time optimization
    if not is_target_macos(target):
        arrput(args, "-flto=full")
    # --
    length: int = 0
    x: int = 0
    # include paths
    length = len(c.c_code.include_paths)
    x = 0
    while x < length:
        include: str = "-I" + c.c_code.include_paths[x]
        arrput(args, include)
        x = x + 1
    # runtime feature compiler defines
    length = len(c.c_code.runtime_feature_compiler_defines)
    x = 0
    while x < length:
        cdefine: str = "-D" + c.c_code.runtime_feature_compiler_defines[x]
        arrput(args, cdefine)
        x = x + 1
    # compiler defines
    length = len(c.c_code.compiler_defines)
    x = 0
    while x < length:
        cdefine: str = "-D" + c.c_code.compiler_defines[x]
        arrput(args, cdefine)
        x = x + 1
    if not native and target != "web":
        arrput(args, "-target")
        arrput(args, target)
    # runtime c codes
    length = len(c.c_code.runtime_feature_c_code)
    x = 0
    while x < length:
        rfc: str = c.c_code.runtime_feature_c_code[x]
        rfc = produce_core_object(args, rfc, build_path, target, False)
        arrput(objects, rfc)
        x = x + 1
    # c codes
    length = len(c.c_code.c_code)
    x = 0
    while x < length:
        cc: str = c.c_code.c_code[x]
        cc = produce_core_object(args, cc, build_path, target, True)
        arrput(objects, cc)
        x = x + 1
    # program code -> this is the yakshac compiled full code
    program_object: str = produce_core_object(args, code_path, build_path, target, True)
    arrput(objects, program_object)
    # yk__main.c -> this has the real main() method
    the_yk_main: str = path.join(c.runtime_path, "yk__main.c")
    the_yk_main = produce_core_object(args, the_yk_main, build_path, target, False)
    arrput(objects, the_yk_main)
    # add objects to the args to link it
    args = sarr.extend(args, objects)
    sarr.del_str_array(objects)
    # Target architecture
    if c.compilation.web and len(c.compilation.web_shell) > 0:
        arrput(args, "--shell-file")
        arrput(args, c.compilation.web_shell)
    # -o bin.exe
    arrput(args, "-o")
    binary: str = c.project.name
    if not native and target != "web":
        binary = binary + "-" + target
    if is_target_windows(target):
        binary = binary + ".exe"
    if target == "web":
        binary = binary + ".html"
    binary = path.join(build_path, binary)
    arrput(args, binary)
    # ----
    return args

def build_target(c: carp.Config, code_path: str, build_path: str, target: str, raylib_args: Array[str]) -> int:
    # Build a single target (platform)
    # if target is empty it is considered to be native (current platform)
    # zero is returned if successful
    native: bool = len(target) == 0
    a: Array[str] = create_args(c, code_path, build_path, target, raylib_args)
    defer sarr.del_str_array(a)
    result: os.ProcessResult = os.run(a)
    defer os.del_process_result(result)
    if native:
        console.yellow("native")
    else:
        console.yellow(target)
    console.cyan(" := ")
    if result.ok:
        console.green("done.\n")
        return 0
    else:
        console.red("failed.\n")
        console.cyan("-------\n")
        console.red("command := ")
        console.yellow(sarr.join(a, " "))
        console.cyan("\n-------\n")
        console.red(result.output)
        return 1

def print_error(error: str, ignored: int) -> bool:
    console.red("error")
    console.yellow(":")
    println(error)
    return True

def build(c: carp.Config, code: str) -> int:
    # Cross build all compilation targets
    # zero is returned if all are successful
    carp.load_runtime_features(c, code)
    if len(c.errors) > 0:
        foreach(c.errors, print_error, 0)
        return -1

    target_count: int = len(c.compilation.targets)
    raylib_args: Array[str]
    defer sarr.del_str_array(raylib_args)

    if target_count != 0 and c.compilation.raylib:
        console.red("raylib build only support native builds.\n")
        console.cyan("Hint: You need to keep [compilation].targets empty\n")
        return -1

    if c.compilation.raylib:
        raylib_args = rs.get_raylib_args(c)

    print("\nbuilding ")
    print(target_count + 1)
    println(" target(s) ...")
    build_path: str = path.join(os.cwd(), "build")
    path.mkdir(build_path)
    code_path: str = path.join(build_path, "program_code.c")
    if not io.writefile(code_path, prepare_code(c, code)):
        console.red("Failed to write file:")
        println(code_path)
        return -1

    failed_count: int = 0

    # Build current system native binary
    failed_count = failed_count + build_target(c, code_path, build_path, "", raylib_args)

    # Building other targets
    cnt: int = 0
    while cnt < len(c.compilation.targets):
        target: str = c.compilation.targets[cnt]
        failed_count = failed_count + build_target(c, code_path, build_path, target, raylib_args)
        cnt = cnt + 1

    print("\n")
    if failed_count > 0:
        return -1
    return 0

def build_simple(c: carp.Config, code: str) -> int:
    # Native build only
    carp.load_runtime_features(c, code)
    if len(c.errors) > 0:
        foreach(c.errors, print_error, 0)
        return -1
    code_path: str = path.join(os.cwd(), c.project.name + ".c")
    raylib_args: Array[str]
    target: str = ""
    if c.compilation.raylib:
        raylib_args = rs.get_raylib_args(c)
    if c.compilation.web:
        target = "web"

    if not io.writefile(code_path, prepare_code(c, code)):
        console.red("Failed to write file:")
        println(code_path)
        return -1

    failed_count: int = build_target(c, code_path, os.cwd(), target, raylib_args)

    if failed_count > 0:
        return -1

    return 0
